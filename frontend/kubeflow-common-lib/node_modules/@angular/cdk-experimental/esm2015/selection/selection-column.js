/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { CdkCellDef, CdkColumnDef, CdkHeaderCellDef, CdkTable } from '@angular/cdk/table';
import { Component, Input, Optional, ViewChild, ChangeDetectionStrategy, ViewEncapsulation, Inject, } from '@angular/core';
import { CdkSelection } from './selection';
/**
 * Column that adds row selecting checkboxes and a select-all checkbox if `cdkSelectionMultiple` is
 * `true`.
 *
 * Must be used within a parent `CdkSelection` directive.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/table';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from './select-all';
import * as ɵngcc4 from './selection-toggle';
import * as ɵngcc5 from './selection';

function CdkSelectionColumn_th_1_input_1_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "input", 5, 6);
    ɵngcc0.ɵɵlistener("click", function CdkSelectionColumn_th_1_input_1_Template_input_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const _r3 = ɵngcc0.ɵɵreference(1); return _r3.toggle($event); });
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵpipe(3, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r3 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("checked", ɵngcc0.ɵɵpipeBind1(2, 2, _r3.checked))("indeterminate", ɵngcc0.ɵɵpipeBind1(3, 4, _r3.indeterminate));
} }
function CdkSelectionColumn_th_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "th", 3);
    ɵngcc0.ɵɵtemplate(1, CdkSelectionColumn_th_1_input_1_Template, 4, 6, "input", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.selection.multiple);
} }
function CdkSelectionColumn_td_2_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 7);
    ɵngcc0.ɵɵelementStart(1, "input", 8, 9);
    ɵngcc0.ɵɵlistener("click", function CdkSelectionColumn_td_2_Template_input_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r10); const _r8 = ɵngcc0.ɵɵreference(2); return _r8.toggle(); });
    ɵngcc0.ɵɵpipe(3, "async");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const row_r6 = ctx.$implicit;
    const i_r7 = ctx.$index;
    const _r8 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("cdkSelectionToggleValue", row_r6)("cdkSelectionToggleIndex", i_r7)("checked", ɵngcc0.ɵɵpipeBind1(3, 3, _r8.checked));
} }
export class CdkSelectionColumn {
    constructor(_table, selection) {
        this._table = _table;
        this.selection = selection;
    }
    /** Column name that should be used to reference this column. */
    get name() {
        return this._name;
    }
    set name(name) {
        this._name = name;
        this._syncColumnDefName();
    }
    ngOnInit() {
        if (!this.selection && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw Error('CdkSelectionColumn: missing CdkSelection in the parent');
        }
        this._syncColumnDefName();
        if (this._table) {
            this._columnDef.cell = this._cell;
            this._columnDef.headerCell = this._headerCell;
            this._table.addColumnDef(this._columnDef);
        }
        else if ((typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw Error('CdkSelectionColumn: missing parent table');
        }
    }
    ngOnDestroy() {
        if (this._table) {
            this._table.removeColumnDef(this._columnDef);
        }
    }
    _syncColumnDefName() {
        if (this._columnDef) {
            this._columnDef.name = this._name;
        }
    }
}
CdkSelectionColumn.ɵfac = function CdkSelectionColumn_Factory(t) { return new (t || CdkSelectionColumn)(ɵngcc0.ɵɵdirectiveInject(CdkTable, 8), ɵngcc0.ɵɵdirectiveInject(CdkSelection, 8)); };
CdkSelectionColumn.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CdkSelectionColumn, selectors: [["cdk-selection-column"]], viewQuery: function CdkSelectionColumn_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(CdkColumnDef, 7);
        ɵngcc0.ɵɵviewQuery(CdkCellDef, 7);
        ɵngcc0.ɵɵviewQuery(CdkHeaderCellDef, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._columnDef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._cell = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._headerCell = _t.first);
    } }, inputs: { name: ["cdkSelectionColumnName", "name"] }, decls: 3, vars: 0, consts: [["cdkColumnDef", ""], ["cdkHeaderCell", "", 4, "cdkHeaderCellDef"], ["cdkCell", "", 4, "cdkCellDef"], ["cdkHeaderCell", ""], ["type", "checkbox", "cdkSelectAll", "", 3, "checked", "indeterminate", "click", 4, "ngIf"], ["type", "checkbox", "cdkSelectAll", "", 3, "checked", "indeterminate", "click"], ["allToggler", "cdkSelectAll"], ["cdkCell", ""], ["type", "checkbox", "cdkSelectionToggle", "", 3, "cdkSelectionToggleValue", "cdkSelectionToggleIndex", "checked", "click"], ["toggler", "cdkSelectionToggle"]], template: function CdkSelectionColumn_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵtemplate(1, CdkSelectionColumn_th_1_Template, 2, 1, "th", 1);
        ɵngcc0.ɵɵtemplate(2, CdkSelectionColumn_td_2_Template, 4, 5, "td", 2);
        ɵngcc0.ɵɵelementContainerEnd();
    } }, directives: [ɵngcc1.CdkColumnDef, ɵngcc1.CdkHeaderCellDef, ɵngcc1.CdkCellDef, ɵngcc2.NgIf, ɵngcc3.CdkSelectAll, ɵngcc4.CdkSelectionToggle], pipes: [ɵngcc2.AsyncPipe], encapsulation: 2, changeDetection: 0 });
CdkSelectionColumn.ctorParameters = () => [
    { type: CdkTable, decorators: [{ type: Optional }, { type: Inject, args: [CdkTable,] }] },
    { type: CdkSelection, decorators: [{ type: Optional }, { type: Inject, args: [CdkSelection,] }] }
];
CdkSelectionColumn.propDecorators = {
    name: [{ type: Input, args: ['cdkSelectionColumnName',] }],
    _columnDef: [{ type: ViewChild, args: [CdkColumnDef, { static: true },] }],
    _cell: [{ type: ViewChild, args: [CdkCellDef, { static: true },] }],
    _headerCell: [{ type: ViewChild, args: [CdkHeaderCellDef, { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkSelectionColumn, [{
        type: Component,
        args: [{
                selector: 'cdk-selection-column',
                template: `
    <ng-container cdkColumnDef>
      <th cdkHeaderCell *cdkHeaderCellDef>
        <input type="checkbox" *ngIf="selection.multiple"
            cdkSelectAll
            #allToggler="cdkSelectAll"
            [checked]="allToggler.checked | async"
            [indeterminate]="allToggler.indeterminate | async"
            (click)="allToggler.toggle($event)">
      </th>
      <td cdkCell *cdkCellDef="let row; let i = $index">
        <input type="checkbox"
            #toggler="cdkSelectionToggle"
            cdkSelectionToggle
            [cdkSelectionToggleValue]="row"
            [cdkSelectionToggleIndex]="i"
            (click)="toggler.toggle()"
            [checked]="toggler.checked | async">
      </td>
    </ng-container>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: ɵngcc1.CdkTable, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [CdkTable]
            }] }, { type: ɵngcc5.CdkSelection, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [CdkSelection]
            }] }]; }, { name: [{
            type: Input,
            args: ['cdkSelectionColumnName']
        }], _columnDef: [{
            type: ViewChild,
            args: [CdkColumnDef, { static: true }]
        }], _cell: [{
            type: ViewChild,
            args: [CdkCellDef, { static: true }]
        }], _headerCell: [{
            type: ViewChild,
            args: [CdkHeaderCellDef, { static: true }]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0aW9uLWNvbHVtbi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2Nkay1leHBlcmltZW50YWwvc2VsZWN0aW9uL3NlbGVjdGlvbi1jb2x1bW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUVILE9BQU8sRUFBQyxVQUFVLEVBQUUsWUFBWSxFQUFFLGdCQUFnQixFQUFFLFFBQVEsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBQ3hGLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUdMLFFBQVEsRUFDUixTQUFTLEVBQ1QsdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixNQUFNLEdBQ1AsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCSCxNQUFNLE9BQU8sa0JBQWtCO0FBQUcsSUFpQmhDLFlBQzBDLE1BQW1CLEVBQ2QsU0FBMEI7QUFDekUsUUFGMEMsV0FBTSxHQUFOLE1BQU0sQ0FBYTtBQUFDLFFBQ2YsY0FBUyxHQUFULFNBQVMsQ0FBaUI7QUFBQyxJQUN2RSxDQUFDO0FBQ04sSUFwQkUsZ0VBQWdFO0FBQ2xFLElBQUUsSUFDSSxJQUFJO0FBQUssUUFDWCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7QUFDdEIsSUFBRSxDQUFDO0FBQ0gsSUFBRSxJQUFJLElBQUksQ0FBQyxJQUFZO0FBQ3ZCLFFBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7QUFDdEIsUUFDSSxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztBQUM5QixJQUFFLENBQUM7QUFDSCxJQVdFLFFBQVE7QUFDVixRQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxJQUFJLENBQUMsT0FBTyxTQUFTLEtBQUssV0FBVyxJQUFJLFNBQVMsQ0FBQyxFQUFFO0FBQzVFLFlBQU0sTUFBTSxLQUFLLENBQUMsd0RBQXdELENBQUMsQ0FBQztBQUM1RSxTQUFLO0FBQ0wsUUFDSSxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztBQUM5QixRQUNJLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNyQixZQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7QUFDeEMsWUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO0FBQ3BELFlBQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ2hELFNBQUs7QUFBQyxhQUFLLElBQUksQ0FBQyxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxDQUFDLEVBQUU7QUFDaEUsWUFBTSxNQUFNLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO0FBQzlELFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSCxJQUNFLFdBQVc7QUFDYixRQUFJLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNyQixZQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNuRCxTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0gsSUFDVSxrQkFBa0I7QUFDNUIsUUFBSSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7QUFDekIsWUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO0FBQ3hDLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSDs4Q0EzRUMsU0FBUyxTQUFDLGtCQUNULFFBQVEsRUFBRSxzQkFBc0Isa0JBQ2hDLFFBQVEsRUFBRTs7Ozs7Ozs7OzswREFvQlQsa0JBQ0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU0sa0JBQy9DLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJLGNBQ3RDOzs7Ozt3TkFDSTtBQUFDO0FBQTRDLFlBL0NFLFFBQVEsdUJBaUVyRCxRQUFRLFlBQUksTUFBTSxTQUFDLFFBQVE7QUFBUyxZQXBEbkMsWUFBWSx1QkFxRGIsUUFBUSxZQUFJLE1BQU0sU0FBQyxZQUFZO0FBQVE7QUFBRztBQUcvQyxtQkFwQkMsS0FBSyxTQUFDLHdCQUF3QjtBQUM1Qix5QkFVRixTQUFTLFNBQUMsWUFBWSxFQUFFLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBQztBQUFPLG9CQUM3QyxTQUFTLFNBQUMsVUFBVSxFQUFFLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBQztBQUFPLDBCQUMzQyxTQUFTLFNBQUMsZ0JBQWdCLEVBQUUsRUFBQyxNQUFNLEVBQUUsSUFBSSxFQUFDO0FBQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7Q2RrQ2VsbERlZiwgQ2RrQ29sdW1uRGVmLCBDZGtIZWFkZXJDZWxsRGVmLCBDZGtUYWJsZX0gZnJvbSAnQGFuZ3VsYXIvY2RrL3RhYmxlJztcbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgVmlld0NoaWxkLFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG4gIEluamVjdCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7Q2RrU2VsZWN0aW9ufSBmcm9tICcuL3NlbGVjdGlvbic7XG5cbi8qKlxuICogQ29sdW1uIHRoYXQgYWRkcyByb3cgc2VsZWN0aW5nIGNoZWNrYm94ZXMgYW5kIGEgc2VsZWN0LWFsbCBjaGVja2JveCBpZiBgY2RrU2VsZWN0aW9uTXVsdGlwbGVgIGlzXG4gKiBgdHJ1ZWAuXG4gKlxuICogTXVzdCBiZSB1c2VkIHdpdGhpbiBhIHBhcmVudCBgQ2RrU2VsZWN0aW9uYCBkaXJlY3RpdmUuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nkay1zZWxlY3Rpb24tY29sdW1uJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyIGNka0NvbHVtbkRlZj5cbiAgICAgIDx0aCBjZGtIZWFkZXJDZWxsICpjZGtIZWFkZXJDZWxsRGVmPlxuICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgKm5nSWY9XCJzZWxlY3Rpb24ubXVsdGlwbGVcIlxuICAgICAgICAgICAgY2RrU2VsZWN0QWxsXG4gICAgICAgICAgICAjYWxsVG9nZ2xlcj1cImNka1NlbGVjdEFsbFwiXG4gICAgICAgICAgICBbY2hlY2tlZF09XCJhbGxUb2dnbGVyLmNoZWNrZWQgfCBhc3luY1wiXG4gICAgICAgICAgICBbaW5kZXRlcm1pbmF0ZV09XCJhbGxUb2dnbGVyLmluZGV0ZXJtaW5hdGUgfCBhc3luY1wiXG4gICAgICAgICAgICAoY2xpY2spPVwiYWxsVG9nZ2xlci50b2dnbGUoJGV2ZW50KVwiPlxuICAgICAgPC90aD5cbiAgICAgIDx0ZCBjZGtDZWxsICpjZGtDZWxsRGVmPVwibGV0IHJvdzsgbGV0IGkgPSAkaW5kZXhcIj5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAjdG9nZ2xlcj1cImNka1NlbGVjdGlvblRvZ2dsZVwiXG4gICAgICAgICAgICBjZGtTZWxlY3Rpb25Ub2dnbGVcbiAgICAgICAgICAgIFtjZGtTZWxlY3Rpb25Ub2dnbGVWYWx1ZV09XCJyb3dcIlxuICAgICAgICAgICAgW2Nka1NlbGVjdGlvblRvZ2dsZUluZGV4XT1cImlcIlxuICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZXIudG9nZ2xlKClcIlxuICAgICAgICAgICAgW2NoZWNrZWRdPVwidG9nZ2xlci5jaGVja2VkIHwgYXN5bmNcIj5cbiAgICAgIDwvdGQ+XG4gICAgPC9uZy1jb250YWluZXI+XG4gIGAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxufSlcbmV4cG9ydCBjbGFzcyBDZGtTZWxlY3Rpb25Db2x1bW48VD4gaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIC8qKiBDb2x1bW4gbmFtZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIGNvbHVtbi4gKi9cbiAgQElucHV0KCdjZGtTZWxlY3Rpb25Db2x1bW5OYW1lJylcbiAgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxuICBzZXQgbmFtZShuYW1lOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcblxuICAgIHRoaXMuX3N5bmNDb2x1bW5EZWZOYW1lKCk7XG4gIH1cbiAgcHJpdmF0ZSBfbmFtZTogc3RyaW5nO1xuXG4gIEBWaWV3Q2hpbGQoQ2RrQ29sdW1uRGVmLCB7c3RhdGljOiB0cnVlfSkgcHJpdmF0ZSByZWFkb25seSBfY29sdW1uRGVmOiBDZGtDb2x1bW5EZWY7XG4gIEBWaWV3Q2hpbGQoQ2RrQ2VsbERlZiwge3N0YXRpYzogdHJ1ZX0pIHByaXZhdGUgcmVhZG9ubHkgX2NlbGw6IENka0NlbGxEZWY7XG4gIEBWaWV3Q2hpbGQoQ2RrSGVhZGVyQ2VsbERlZiwge3N0YXRpYzogdHJ1ZX0pIHByaXZhdGUgcmVhZG9ubHkgX2hlYWRlckNlbGw6IENka0hlYWRlckNlbGxEZWY7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KENka1RhYmxlKSBwcml2YXRlIF90YWJsZTogQ2RrVGFibGU8VD4sXG4gICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KENka1NlbGVjdGlvbikgcmVhZG9ubHkgc2VsZWN0aW9uOiBDZGtTZWxlY3Rpb248VD4sXG4gICkge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAoIXRoaXMuc2VsZWN0aW9uICYmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2RrU2VsZWN0aW9uQ29sdW1uOiBtaXNzaW5nIENka1NlbGVjdGlvbiBpbiB0aGUgcGFyZW50Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3luY0NvbHVtbkRlZk5hbWUoKTtcblxuICAgIGlmICh0aGlzLl90YWJsZSkge1xuICAgICAgdGhpcy5fY29sdW1uRGVmLmNlbGwgPSB0aGlzLl9jZWxsO1xuICAgICAgdGhpcy5fY29sdW1uRGVmLmhlYWRlckNlbGwgPSB0aGlzLl9oZWFkZXJDZWxsO1xuICAgICAgdGhpcy5fdGFibGUuYWRkQ29sdW1uRGVmKHRoaXMuX2NvbHVtbkRlZik7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0Nka1NlbGVjdGlvbkNvbHVtbjogbWlzc2luZyBwYXJlbnQgdGFibGUnKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fdGFibGUpIHtcbiAgICAgIHRoaXMuX3RhYmxlLnJlbW92ZUNvbHVtbkRlZih0aGlzLl9jb2x1bW5EZWYpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3N5bmNDb2x1bW5EZWZOYW1lKCkge1xuICAgIGlmICh0aGlzLl9jb2x1bW5EZWYpIHtcbiAgICAgIHRoaXMuX2NvbHVtbkRlZi5uYW1lID0gdGhpcy5fbmFtZTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==