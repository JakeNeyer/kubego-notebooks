{"version":3,"file":"auto-size-virtual-scroll.d.ts","sources":["auto-size-virtual-scroll.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { NumberInput } from '@angular/cdk/coercion';\nimport { ListRange } from '@angular/cdk/collections';\nimport { CdkVirtualScrollViewport, VirtualScrollStrategy } from '@angular/cdk/scrolling';\nimport { OnChanges } from '@angular/core';\nimport { Observable } from 'rxjs';\n/**\n * A class that tracks the size of items that have been seen and uses it to estimate the average\n * item size.\n */\nexport declare class ItemSizeAverager {\n    /** The total amount of weight behind the current average. */\n    private _totalWeight;\n    /** The current average item size. */\n    private _averageItemSize;\n    /** The default size to use for items when no data is available. */\n    private _defaultItemSize;\n    /** @param defaultItemSize The default size to use for items when no data is available. */\n    constructor(defaultItemSize?: number);\n    /** Returns the average item size. */\n    getAverageItemSize(): number;\n    /**\n     * Adds a measurement sample for the estimator to consider.\n     * @param range The measured range.\n     * @param size The measured size of the given range in pixels.\n     */\n    addSample(range: ListRange, size: number): void;\n    /** Resets the averager. */\n    reset(): void;\n}\n/** Virtual scrolling strategy for lists with items of unknown or dynamic size. */\nexport declare class AutoSizeVirtualScrollStrategy implements VirtualScrollStrategy {\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    scrolledIndexChange: Observable<number>;\n    /** The attached viewport. */\n    private _viewport;\n    /** The minimum amount of buffer rendered beyond the viewport (in pixels). */\n    private _minBufferPx;\n    /** The number of buffer items to render beyond the edge of the viewport (in pixels). */\n    private _maxBufferPx;\n    /** The estimator used to estimate the size of unseen items. */\n    private _averager;\n    /** The last measured scroll offset of the viewport. */\n    private _lastScrollOffset;\n    /** The last measured size of the rendered content in the viewport. */\n    private _lastRenderedContentSize;\n    /** The last measured size of the rendered content in the viewport. */\n    private _lastRenderedContentOffset;\n    /**\n     * The number of consecutive cycles where removing extra items has failed. Failure here means that\n     * we estimated how many items we could safely remove, but our estimate turned out to be too much\n     * and it wasn't safe to remove that many elements.\n     */\n    private _removalFailures;\n    /**\n     * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n     *     If the amount of buffer dips below this number, more items will be rendered.\n     * @param maxBufferPx The number of pixels worth of buffer to shoot for when rendering new items.\n     *     If the actual amount turns out to be less it will not necessarily trigger an additional\n     *     rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n     * @param averager The averager used to estimate the size of unseen items.\n     */\n    constructor(minBufferPx: number, maxBufferPx: number, averager?: ItemSizeAverager);\n    /**\n     * Attaches this scroll strategy to a viewport.\n     * @param viewport The viewport to attach this strategy to.\n     */\n    attach(viewport: CdkVirtualScrollViewport): void;\n    /** Detaches this scroll strategy from the currently attached viewport. */\n    detach(): void;\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentScrolled(): void;\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onDataLengthChanged(): void;\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentRendered(): void;\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onRenderedOffsetChanged(): void;\n    /** Scroll to the offset for the given index. */\n    scrollToIndex(): void;\n    /**\n     * Update the buffer parameters.\n     * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n     * @param maxBufferPx The number of buffer items to render beyond the edge of the viewport (in\n     *     pixels).\n     */\n    updateBufferSize(minBufferPx: number, maxBufferPx: number): void;\n    /** Update the rendered content after the user scrolls. */\n    private _updateRenderedContentAfterScroll;\n    /**\n     * Checks the size of the currently rendered content and uses it to update the estimated item size\n     * and estimated total content size.\n     */\n    private _checkRenderedContentSize;\n    /** Checks the currently rendered content offset and saves the value for later use. */\n    private _checkRenderedContentOffset;\n    /**\n     * Recalculates the rendered content based on our estimate of what should be shown at the current\n     * scroll offset.\n     */\n    private _renderContentForCurrentOffset;\n    /**\n     * Gets the visible range of data for the given start index. If the start index is too close to\n     * the end of the list it may be backed up to ensure the estimated size of the range is enough to\n     * fill the viewport.\n     * Note: must not be called if `this._viewport` is null\n     * @param startIndex The index to start the range at\n     * @return a range estimated to be large enough to fill the viewport when rendered.\n     */\n    private _getVisibleRangeForIndex;\n    /**\n     * Expand the given range by the given amount in either direction.\n     * Note: must not be called if `this._viewport` is null\n     * @param range The range to expand\n     * @param expandStart The number of items to expand the start of the range by.\n     * @param expandEnd The number of items to expand the end of the range by.\n     * @return The expanded range.\n     */\n    private _expandRange;\n    /** Update the viewport's total content size. */\n    private _updateTotalContentSize;\n}\n/**\n * Provider factory for `AutoSizeVirtualScrollStrategy` that simply extracts the already created\n * `AutoSizeVirtualScrollStrategy` from the given directive.\n * @param autoSizeDir The instance of `CdkAutoSizeVirtualScroll` to extract the\n *     `AutoSizeVirtualScrollStrategy` from.\n */\nexport declare function _autoSizeVirtualScrollStrategyFactory(autoSizeDir: CdkAutoSizeVirtualScroll): AutoSizeVirtualScrollStrategy;\n/** A virtual scroll strategy that supports unknown or dynamic size items. */\nexport declare class CdkAutoSizeVirtualScroll implements OnChanges {\n    /**\n     * The minimum amount of buffer rendered beyond the viewport (in pixels).\n     * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n     */\n    get minBufferPx(): number;\n    set minBufferPx(value: number);\n    _minBufferPx: number;\n    /**\n     * The number of pixels worth of buffer to shoot for when rendering new items.\n     * If the actual amount turns out to be less it will not necessarily trigger an additional\n     * rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n     * Defaults to 200px.\n     */\n    get maxBufferPx(): number;\n    set maxBufferPx(value: number);\n    _maxBufferPx: number;\n    /** The scroll strategy used by this directive. */\n    _scrollStrategy: AutoSizeVirtualScrollStrategy;\n    ngOnChanges(): void;\n    static ngAcceptInputType_minBufferPx: NumberInput;\n    static ngAcceptInputType_maxBufferPx: NumberInput;\n}\n"]}